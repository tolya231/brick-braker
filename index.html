<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Brick Breaker</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
      touch-action: none;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #gameCanvas {
      display: block;
      background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
      touch-action: none;
      flex: 1;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
      pointer-events: none;
    }

    .ui-item {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      padding: 8px 16px;
      border-radius: 15px;
      color: white;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    #gameOver, #menu, #leaderboard {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      padding: 20px;
    }

    .modal-content {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px;
      border-radius: 30px;
      text-align: center;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    h1 {
      color: white;
      font-size: 48px;
      margin-bottom: 10px;
      text-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }

    h2 {
      color: white;
      font-size: 32px;
      margin-bottom: 20px;
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    p {
      color: rgba(255, 255, 255, 0.9);
      font-size: 18px;
      margin-bottom: 30px;
    }

    button {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border: none;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      margin: 10px;
      box-shadow: 0 10px 30px rgba(245, 87, 108, 0.4);
      transition: transform 0.2s, box-shadow 0.2s;
      pointer-events: auto;
    }

    button:active {
      transform: scale(0.95);
      box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
    }

    button.secondary {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      box-shadow: 0 10px 30px rgba(79, 172, 254, 0.4);
    }

    button.star-button {
      background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
      box-shadow: 0 10px 30px rgba(255, 210, 0, 0.4);
    }

    #leaderboardList {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 20px;
      margin: 20px 0;
      max-height: 400px;
      overflow-y: auto;
      width: 100%;
    }

    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      margin: 10px 0;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 15px;
      color: white;
    }

    .leaderboard-rank {
      font-size: 24px;
      font-weight: bold;
      width: 40px;
    }

    .leaderboard-name {
      flex: 1;
      font-size: 18px;
    }

    .leaderboard-score {
      font-size: 20px;
      font-weight: bold;
      color: #ffd200;
    }

    .hidden {
      display: none !important;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    .pulse {
      animation: pulse 0.5s ease-in-out;
    }
  </style>
</head>
<body>
<div id="gameContainer">
  <div id="ui">
    <div class="ui-item">‚ù§Ô∏è <span id="lives">3</span></div>
    <div class="ui-item">‚≠ê <span id="score">0</span></div>
    <div class="ui-item">–£—Ä. <span id="level">1</span></div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <!-- Main Menu -->
  <div id="menu">
    <div class="modal-content">
      <h1>üéÆ BRICK BREAKER</h1>
      <p>–†–∞–∑–±–∏–≤–∞–π –±–ª–æ–∫–∏ –∏ —Å–æ–±–∏—Ä–∞–π –±–æ–Ω—É—Å—ã!</p>
      <button onclick="startGame()">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
      <button class="secondary" onclick="showLeaderboard()">üèÜ –õ–∏–¥–µ—Ä–±–æ—Ä–¥</button>
    </div>
  </div>

  <!-- Game Over Screen -->
  <div id="gameOver" class="hidden">
    <div class="modal-content">
      <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
      <p>–í–∞—à —Å—á—ë—Ç: <span id="finalScore">0</span></p>
      <p id="continueOffer" class="hidden">–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∑–∞ ‚≠ê –∑–≤–µ–∑–¥—É?</p>
      <button id="continueBtn" class="star-button hidden" onclick="buyContinue()">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∑–∞ ‚≠ê</button>
      <button onclick="restartGame()">–ó–∞–Ω–æ–≤–æ</button>
      <button class="secondary" onclick="showMenu()">–ú–µ–Ω—é</button>
    </div>
  </div>

  <!-- Leaderboard -->
  <div id="leaderboard" class="hidden">
    <div class="modal-content">
      <h2>üèÜ –õ–∏–¥–µ—Ä–±–æ—Ä–¥</h2>
      <div id="leaderboardList"></div>
      <button class="secondary" onclick="showMenu()">–ù–∞–∑–∞–¥</button>
    </div>
  </div>
</div>

<script>
  // Telegram WebApp initialization
  const tg = window.Telegram.WebApp;
  tg.expand();
  tg.enableClosingConfirmation();

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Responsive canvas
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 0;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // Game state
  let gameState = {
    playing: false,
    paused: false,
    score: 0,
    level: 1,
    lives: 3,
    usedContinue: false,
    savedState: null
  };

  // Game objects
  let paddle = {
    width: 100,
    height: 15,
    x: 0,
    y: 0,
    speed: 10,
    dx: 0
  };

  let balls = [];
  let bricks = [];
  let powerups = [];

  // Colors
  const colors = {
    paddle: '#f093fb',
    ball: '#00f2fe',
    bricks: ['#f093fb', '#f5576c', '#4facfe', '#00f2fe', '#ffd200', '#7f00ff'],
    powerup: '#ffd200'
  };

  // Initialize paddle position
  function initPaddle() {
    paddle.x = canvas.width / 2 - paddle.width / 2;
    paddle.y = canvas.height - 120; // Higher up
  }

  // Create ball
  function createBall(x, y) {
    return {
      x: x || canvas.width / 2,
      y: y || canvas.height - 150,
      radius: 8,
      speed: 6, // Reduced from 16.8
      dx: (Math.random() - 0.5) * 9,
      dy: -6
    };
  }

  // Generate maze-like level
  function generateLevel(level) {
    bricks = [];
    const rows = 18;
    const cols = 20;
    const brickWidth = 16;
    const brickHeight = 16;
    const padding = 2;
    const startX = (canvas.width - (cols * (brickWidth + padding))) / 2;

    // Create maze structure - true = wall (unbreakable), false = corridor (breakable)
    const maze = [];
    for (let row = 0; row < rows; row++) {
      maze[row] = [];
      for (let col = 0; col < cols; col++) {
        // Start with all breakable
        maze[row][col] = false;
      }
    }

    // Pattern based on level
    const pattern = level % 5;

    if (pattern === 0) {
      // L-shaped corridors pattern
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          // Create vertical walls every 6 columns
          if (col % 6 === 0 && row % 4 !== 0) {
            maze[row][col] = true;
          }
          // Create horizontal walls every 5 rows with gaps
          if (row % 5 === 0 && col % 3 !== 0) {
            maze[row][col] = true;
          }
        }
      }
    } else if (pattern === 1) {
      // Grid pattern with wide corridors
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          // Horizontal walls
          if (row % 6 === 0 || row % 6 === 1) {
            if (col % 5 !== 2 && col % 5 !== 3) {
              maze[row][col] = true;
            }
          }
          // Vertical walls
          if (col % 5 === 0) {
            if (row % 6 !== 3 && row % 6 !== 4) {
              maze[row][col] = true;
            }
          }
        }
      }
    } else if (pattern === 2) {
      // Zigzag corridors
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const segment = Math.floor(row / 4);
          if (segment % 2 === 0) {
            // Horizontal corridors
            if (col % 7 === 0 && row % 4 !== 2) {
              maze[row][col] = true;
            }
          } else {
            // Vertical walls
            if (row % 4 === 0 && col % 4 !== 2) {
              maze[row][col] = true;
            }
          }
        }
      }
    } else if (pattern === 3) {
      // Rooms with doorways
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          // Room walls
          if (row % 8 === 0 && col % 4 !== 2) {
            maze[row][col] = true;
          }
          if (col % 8 === 0 && row % 4 !== 2) {
            maze[row][col] = true;
          }
        }
      }
    } else {
      // Sparse scattered walls
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          // Create islands of walls
          if ((row % 7 === 0 || row % 7 === 1) && col % 5 !== 2) {
            maze[row][col] = true;
          }
          if (col % 9 === 0 && row % 3 !== 1) {
            maze[row][col] = true;
          }
        }
      }
    }

    // Create bricks based on maze
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = startX + col * (brickWidth + padding);
        const y = 100 + row * (brickHeight + padding);

        const isWall = maze[row][col];

        if (isWall) {
          // Unbreakable wall block
          bricks.push({
            x, y,
            width: brickWidth,
            height: brickHeight,
            health: 999,
            maxHealth: 999,
            visible: true,
            unbreakable: true
          });
        } else {
          // Breakable corridor block
          const health = Math.min(Math.floor(level / 3) + 1, 3);
          bricks.push({
            x, y,
            width: brickWidth,
            height: brickHeight,
            health,
            maxHealth: health,
            visible: true,
            unbreakable: false
          });
        }
      }
    }
  }

  // Create powerup
  function createPowerup(x, y) {
    const types = ['multiball', 'speed', 'wide'];
    const type = types[Math.floor(Math.random() * types.length)];

    powerups.push({
      x,
      y,
      width: 30,
      height: 30,
      type,
      dy: 2,
      icon: type === 'multiball' ? '‚ö°' : type === 'speed' ? 'üöÄ' : 'üìè'
    });
  }

  // Draw functions
  function drawPaddle() {
    const gradient = ctx.createLinearGradient(paddle.x, 0, paddle.x + paddle.width, 0);
    gradient.addColorStop(0, '#f093fb');
    gradient.addColorStop(1, '#f5576c');

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 10);
    ctx.fill();
  }

  function drawBall(ball) {
    const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
    gradient.addColorStop(0, '#ffffff');
    gradient.addColorStop(1, colors.ball);

    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawBricks() {
    bricks.forEach(brick => {
      if (!brick.visible) return;

      if (brick.unbreakable) {
        // Unbreakable blocks - gray/silver color with pattern
        const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
        gradient.addColorStop(0, '#9ca3af');
        gradient.addColorStop(0.5, '#6b7280');
        gradient.addColorStop(1, '#4b5563');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(brick.x, brick.y, brick.width, brick.height, 5);
        ctx.fill();

        // Stripes pattern for unbreakable
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(brick.x, brick.y + brick.height / 2);
        ctx.lineTo(brick.x + brick.width, brick.y + brick.height / 2);
        ctx.stroke();
      } else {
        // Normal breakable blocks
        const colorIndex = Math.min(brick.health - 1, colors.bricks.length - 1);
        const gradient = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
        gradient.addColorStop(0, colors.bricks[colorIndex]);
        gradient.addColorStop(1, colors.bricks[(colorIndex + 1) % colors.bricks.length]);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(brick.x, brick.y, brick.width, brick.height, 5);
        ctx.fill();

        // Health indicator
        if (brick.health > 1) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(brick.health, brick.x + brick.width / 2, brick.y + brick.height / 2 + 5);
        }
      }
    });
  }

  function drawPowerups() {
    powerups.forEach(powerup => {
      ctx.fillStyle = colors.powerup;
      ctx.shadowBlur = 15;
      ctx.shadowColor = colors.powerup;
      ctx.beginPath();
      ctx.roundRect(powerup.x, powerup.y, powerup.width, powerup.height, 8);
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(powerup.icon, powerup.x + powerup.width / 2, powerup.y + powerup.height / 2 + 7);
    });
  }

  // Update functions
  function updateBalls() {
    balls = balls.filter(ball => {
      // Store old position for collision detection
      const oldX = ball.x;
      const oldY = ball.y;

      ball.x += ball.dx;
      ball.y += ball.dy;

      // Prevent ball from getting stuck - ensure minimum velocity
      const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
      if (speed < 3) {
        const angle = Math.atan2(ball.dy, ball.dx);
        ball.dx = Math.cos(angle) * 6;
        ball.dy = Math.sin(angle) * 6;
      }

      // Cap maximum velocity
      const maxSpeed = 12;
      if (speed > maxSpeed) {
        const ratio = maxSpeed / speed;
        ball.dx *= ratio;
        ball.dy *= ratio;
      }

      // Wall collision - bounce from sides
      if (ball.x + ball.radius > canvas.width) {
        ball.dx = -Math.abs(ball.dx);
        ball.x = canvas.width - ball.radius;
      }
      if (ball.x - ball.radius < 0) {
        ball.dx = Math.abs(ball.dx);
        ball.x = ball.radius;
      }

      // Top boundary at 90px
      if (ball.y - ball.radius < 90) {
        ball.dy = Math.abs(ball.dy);
        ball.y = 90 + ball.radius;
      }

      // Paddle collision
      if (ball.dy > 0 &&
              ball.y + ball.radius >= paddle.y &&
              ball.y + ball.radius <= paddle.y + paddle.height + 5 &&
              ball.x >= paddle.x &&
              ball.x <= paddle.x + paddle.width) {

        ball.dy = -Math.abs(ball.dy);
        ball.y = paddle.y - ball.radius;

        // Add angle based on hit position
        const hitPos = (ball.x - paddle.x) / paddle.width;
        ball.dx = (hitPos - 0.5) * 8; // Reduced from 14
      }

      // Brick collision - check trajectory for tunneling prevention
      let collisionHandled = false;

      bricks.forEach(brick => {
        if (!brick.visible || collisionHandled) return;

        // Expanded collision box for fast-moving ball
        const expandedRadius = ball.radius + 2;

        // Check if ball's trajectory intersects brick
        const ballInBrickX = ball.x > brick.x - expandedRadius &&
                ball.x < brick.x + brick.width + expandedRadius;
        const ballInBrickY = ball.y > brick.y - expandedRadius &&
                ball.y < brick.y + brick.height + expandedRadius;

        if (!ballInBrickX || !ballInBrickY) return;

        // More precise collision detection
        const closestX = Math.max(brick.x, Math.min(ball.x, brick.x + brick.width));
        const closestY = Math.max(brick.y, Math.min(ball.y, brick.y + brick.height));

        const distanceX = ball.x - closestX;
        const distanceY = ball.y - closestY;
        const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

        if (distance < ball.radius) {
          collisionHandled = true;

          // Check which edge was crossed using old position
          const wasLeft = oldX < brick.x;
          const wasRight = oldX > brick.x + brick.width;
          const wasTop = oldY < brick.y;
          const wasBottom = oldY > brick.y + brick.height;

          const isLeft = ball.x < brick.x;
          const isRight = ball.x > brick.x + brick.width;
          const isTop = ball.y < brick.y;
          const isBottom = ball.y > brick.y + brick.height;

          // Determine collision type based on trajectory
          let hitHorizontal = false;
          let hitVertical = false;

          // Check if crossed vertical edges
          if ((wasLeft && !isLeft) || (wasRight && !isRight)) {
            hitHorizontal = true;
          }

          // Check if crossed horizontal edges
          if ((wasTop && !isTop) || (wasBottom && !isBottom)) {
            hitVertical = true;
          }

          // Handle corner hits (diagonal)
          if (hitHorizontal && hitVertical) {
            // Both directions - bounce both
            ball.dx *= -1;
            ball.dy *= -1;
          } else if (hitHorizontal) {
            // Horizontal hit
            ball.dx *= -1;
            if (wasLeft) {
              ball.x = brick.x - ball.radius;
            } else {
              ball.x = brick.x + brick.width + ball.radius;
            }
          } else if (hitVertical) {
            // Vertical hit
            ball.dy *= -1;
            if (wasTop) {
              ball.y = brick.y - ball.radius;
            } else {
              ball.y = brick.y + brick.height + ball.radius;
            }
          } else {
            // Fallback: bounce based on current position
            const distToLeft = Math.abs(ball.x - brick.x);
            const distToRight = Math.abs(ball.x - (brick.x + brick.width));
            const distToTop = Math.abs(ball.y - brick.y);
            const distToBottom = Math.abs(ball.y - (brick.y + brick.height));

            const minHorizontal = Math.min(distToLeft, distToRight);
            const minVertical = Math.min(distToTop, distToBottom);

            if (minHorizontal < minVertical) {
              ball.dx *= -1;
              if (distToLeft < distToRight) {
                ball.x = brick.x - ball.radius;
              } else {
                ball.x = brick.x + brick.width + ball.radius;
              }
            } else {
              ball.dy *= -1;
              if (distToTop < distToBottom) {
                ball.y = brick.y - ball.radius;
              } else {
                ball.y = brick.y + brick.height + ball.radius;
              }
            }
          }

          if (!brick.unbreakable) {
            brick.health--;

            if (brick.health <= 0) {
              brick.visible = false;
              gameState.score += 10;
              updateScore();

              // Calculate remaining breakable bricks
              const remainingBricks = bricks.filter(b => b.visible && !b.unbreakable).length;

              // Increase powerup drop rate as level progresses
              let dropChance = 0.04; // Base 4%

              if (remainingBricks < 50) {
                dropChance = 0.12; // 12% when less than 50 bricks left
              } else if (remainingBricks < 100) {
                dropChance = 0.08; // 8% when less than 100 bricks left
              }

              if (Math.random() < dropChance) {
                createPowerup(brick.x + brick.width / 2, brick.y);
              }
            }
          }
        }
      });

      // Ball lost
      if (ball.y - ball.radius > canvas.height) {
        return false;
      }

      return true;
    });

    if (balls.length === 0) {
      loseLife();
    }
  }

  function updatePaddle() {
    paddle.x += paddle.dx;
    paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
  }

  function updatePowerups() {
    powerups = powerups.filter(powerup => {
      powerup.y += powerup.dy;

      // Paddle collision
      if (powerup.y + powerup.height > paddle.y &&
              powerup.y < paddle.y + paddle.height &&
              powerup.x + powerup.width > paddle.x &&
              powerup.x < paddle.x + paddle.width) {

        activatePowerup(powerup.type);
        return false;
      }

      return powerup.y < canvas.height;
    });
  }

  function activatePowerup(type) {
    switch(type) {
      case 'multiball':
        if (balls.length > 0) {
          const newBalls = balls.map(ball => createBall(ball.x, ball.y));
          balls.push(...newBalls);
        }
        break;
      case 'speed':
        balls.forEach(ball => {
          ball.speed *= 1.2; // Reduced from 1.3
          ball.dx *= 1.2;
          ball.dy *= 1.2;
        });
        break;
      case 'wide':
        paddle.width = Math.min(150, paddle.width * 1.5);
        setTimeout(() => {
          paddle.width = 100;
        }, 5000);
        break;
    }
  }

  function checkLevelComplete() {
    const visibleBricks = bricks.filter(b => b.visible && !b.unbreakable).length;
    if (visibleBricks === 0) {
      nextLevel();
    }
  }

  function nextLevel() {
    gameState.level++;
    updateLevel();
    generateLevel(gameState.level);
    balls = [createBall()];
    powerups = [];
    gameState.paused = true;

    setTimeout(() => {
      gameState.paused = false;
    }, 1000);
  }

  function loseLife() {
    gameState.lives--;
    updateLives();

    if (gameState.lives > 0) {
      balls = [createBall()];
      gameState.paused = true;
      setTimeout(() => {
        gameState.paused = false;
      }, 1000);
    } else {
      endGame();
    }
  }

  function endGame() {
    gameState.playing = false;

    // Save state for continue option
    if (!gameState.usedContinue) {
      gameState.savedState = {
        level: gameState.level,
        score: gameState.score,
        bricks: JSON.parse(JSON.stringify(bricks))
      };
      document.getElementById('continueOffer').classList.remove('hidden');
      document.getElementById('continueBtn').classList.remove('hidden');
    }

    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('gameOver').classList.remove('hidden');

    saveScore(gameState.score);
  }

  // UI Updates
  function updateScore() {
    document.getElementById('score').textContent = gameState.score;
  }

  function updateLives() {
    document.getElementById('lives').textContent = gameState.lives;
  }

  function updateLevel() {
    document.getElementById('level').textContent = gameState.level;
  }

  // Game loop
  let lastTime = 0;
  function gameLoop(currentTime) {
    if (!gameState.playing) return;

    // Calculate delta time for consistent physics
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;

    if (gameState.paused) {
      requestAnimationFrame(gameLoop);
      return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBricks();
    drawPaddle();
    balls.forEach(drawBall);
    drawPowerups();

    updatePaddle();
    updateBalls();
    updatePowerups();
    checkLevelComplete();

    requestAnimationFrame(gameLoop);
  }

  // Controls
  let touchX = 0;

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchX = touch.clientX - rect.left;
    paddle.x = touchX - paddle.width / 2;
  });

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchX = touch.clientX - rect.left;
  });

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    paddle.x = e.clientX - rect.left - paddle.width / 2;
  });

  // Menu functions
  function showMenu() {
    document.getElementById('menu').classList.remove('hidden');
    document.getElementById('gameOver').classList.add('hidden');
    document.getElementById('leaderboard').classList.add('hidden');
    gameState.playing = false;
  }

  function startGame() {
    gameState = {
      playing: true,
      paused: false,
      score: 0,
      level: 1,
      lives: 3,
      usedContinue: false,
      savedState: null
    };

    updateScore();
    updateLives();
    updateLevel();

    document.getElementById('menu').classList.add('hidden');
    document.getElementById('gameOver').classList.add('hidden');

    initPaddle();
    generateLevel(1);
    balls = [createBall()];
    powerups = [];

    gameLoop();
  }

  function restartGame() {
    startGame();
  }

  function buyContinue() {
    if (gameState.savedState && !gameState.usedContinue) {
      // Check if Telegram Stars is available
      if (!tg.StarsPayment) {
        tg.showAlert('–û–ø–ª–∞—Ç–∞ –∑–≤—ë–∑–¥–∞–º–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å Telegram.');
        return;
      }

      // Create invoice link for 1 Star
      const invoiceLink = tg.createInvoiceLink({
        title: '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É',
        description: '–ü–æ–ª—É—á–∏—Ç–µ 2 –∂–∏–∑–Ω–∏ –∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ —Å —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è',
        currency: 'XTR',
        prices: [{ label: '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å', amount: 1 }],
        payload: JSON.stringify({
          action: 'continue',
          level: gameState.savedState.level,
          score: gameState.savedState.score
        })
      });

      // Open Stars payment
      tg.openInvoice(invoiceLink, (status) => {
        if (status === 'paid') {
          continuePlaying();
          tg.showAlert('–ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∞! –£–¥–∞—á–∏! üéÆ');
        } else if (status === 'cancelled') {
          // User cancelled - do nothing
        } else if (status === 'failed') {
          tg.showAlert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å –æ–ø–ª–∞—Ç—É');
        }
      });
    }
  }

  function continuePlaying() {
    gameState.lives = 2;
    gameState.usedContinue = true;
    gameState.level = gameState.savedState.level;
    gameState.score = gameState.savedState.score;
    bricks = JSON.parse(JSON.stringify(gameState.savedState.bricks));

    updateScore();
    updateLives();
    updateLevel();

    document.getElementById('gameOver').classList.add('hidden');

    balls = [createBall()];
    gameState.playing = true;
    gameState.paused = false;

    gameLoop();
  }

  // Leaderboard
  function showLeaderboard() {
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('leaderboard').classList.remove('hidden');
    loadLeaderboard();
  }

  function loadLeaderboard() {
    const scores = getScores();
    const listDiv = document.getElementById('leaderboardList');

    if (scores.length === 0) {
      listDiv.innerHTML = '<p style="color: white; text-align: center;">–ü–æ–∫–∞ –Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</p>';
      return;
    }

    listDiv.innerHTML = scores.map((score, index) => `
                <div class="leaderboard-item">
                    <div class="leaderboard-rank">${index + 1}</div>
                    <div class="leaderboard-name">${score.name}</div>
                    <div class="leaderboard-score">${score.score}</div>
                </div>
            `).join('');
  }

  function saveScore(score) {
    const scores = getScores();
    const userName = tg.initDataUnsafe?.user?.first_name || '–ò–≥—Ä–æ–∫';

    scores.push({
      name: userName,
      score: score,
      date: Date.now()
    });

    scores.sort((a, b) => b.score - a.score);
    localStorage.setItem('leaderboard', JSON.stringify(scores.slice(0, 10)));
  }

  function getScores() {
    const data = localStorage.getItem('leaderboard');
    return data ? JSON.parse(data) : [];
  }

  // Initialize
  initPaddle();
</script>
</body>
</html>